addiu $1, $0, 0x48 // put H into $1
sb $1, 0x30 ($0) // store H at 0x0   
addiu $1, $0, 0x69 // put i in $1
sb $1, 0x31 ($0) // store i in 0x1
addiu $1, $0, 0x20 // put ' ' in $1
sb $1, 0x32 ($0) // store ' ' in 0x2
addiu $1, $0, 0x4a // put J in $1
sb $1, 0x33 ($0) // store J in 0x3
addiu $1, $0, 0x6f // put o in $1
sb $1, 0x34 ($0) // store o in 0x4
addiu $1, $0, 0x65 // put e in $1
sb $1, 0x35 ($0) // store e in 0x5
addiu $1, $0, 0x21 // put ! in $1
sb $1, 0x36 ($0) // store ! in 0x6
sb $0, 0x37 ($0) // put null byte at 0x7
li, $4, 0x030 // put memory address 0x030 into $4
li, $5, 0x060 // put memory address 0x060 into $5
or, $6, $4, $0 // $6 = $4 | 0 (copy memory address of s into p in $6)
lb, $3, 0 ($6) // load the first byte, at address p, into $3
beq, $3, $0, 5 // branch if ch == 0; skip next 5 instructions
sb, $3, 0 ($5) // store ch($3) at position D($5)
addiu, $5, $5, 1 // add 1 to d
addiu, $6, $6, 1 // add 1 to p
lb, $3, 0 ($6) // load the byte at p
j, 0xC // jump to location 0xC
sb, $5, 0 ($0) // store a null byte at d
sub, $2, $6, $4 // compute n = P-S